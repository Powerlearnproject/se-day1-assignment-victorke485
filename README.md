[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18420655&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering refer to the processes of designing, developing, testing and maintainance of software applications. It's importance include:
  1. Ensures that softwares are reliable and function as expected.
  2. Designs systems that can handle more users and data as they grow, without losing performance.
  3. Optimizes software to run smoothly, saving resources and improving user experience.
  4. Identifies and fixes security issues to protect sensitive data and prevent cyberattacks.


Identify and describe at least three key milestones in the evolution of software engineering.
  1. Birth of Software Engineering (1960s)- Back then, coding was a free-for-all with no real plan, but software was getting tricky and messy. In the 1960s, during the "Software Crisis," people started calling it “software engineering” to make it more serious. It pushed for organized ways to build software, like using better methods and early coding languages. This kicked off software engineering as a real job.
  2. Waterfall Model (1970s)- In the 1970s, the Waterfall Model came along—a step-by-step way to make software. You finish one part (like planning or coding) before moving to the next, like a checklist. It made things orderly and clear, helping teams stay on track. Even though it’s stiff, it shaped how people think about building software and still gets used sometimes.
  3. Agile Software Development (1990s-2000s)- In the late 1990s and 2000s, Agile showed up, shaking things up. It’s all about being flexible, working with users, and building software in small, quick chunks. The Agile Manifesto in 2001 laid out the big ideas, like adapting fast and delivering often. It sped up development, made teamwork better

List and briefly explain the phases of the Software Development Life Cycle.
  1. Requirements Gathering and Analysis: Talk to the people who want the software to figure out what it needs to do. Write down all the details.
  2. System Design: Plan how the software will work and look.
  3. Coding: This is where people type the instructions (code) that tell the computer what to do, based on the plan.
  4. Testing: Check the software to find bugs and fix them. Make sure it does what it’s supposed to.
  5. Deployment: Put the software out into the world—like for people to use it.
  6. Maintenance: Keep an eye on it after it’s out. Fix problems, add new stuff, or update it so it doesn’t get old and stop working.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

  Waterfall methodology: Is a straightforward way to build software where you finish one step before starting the next. It’s great because it’s super organized and you know what you’ll get from the start but if something goes wrong late, it’s tough to fix earlier steps, and it takes longer since users only see it at the end. It works best for projects like large government systems or infrastructure software.
  
  Agile methodology: Software is build in small pieces, show them to users, get their ideas, and keep improving it bit by bit. It’s awesome because you can change things anytime and get usable stuff out fast, like a basic app you update based on what people say. The downside is it’s less predictable and needs lots of teamwork, which can feel messy if you like strict plans. It’s perfect for something like a social media app, where you start simple and add features as users’ wants change.
 
  How they compare: Waterfall moves in a straight line with no turning back, while Agile zigzags with lots of check-ins; Waterfall locks the plan early and hates changes, but Agile expects them and adjusts all the time. Waterfall takes longer to finish fully, while Agile gets stuff out quicker, and Waterfall shows users the final product at the end, but Agile involves them from the start. Waterfall plans everything upfront, whereas Agile figures it out as it goes—each fits different needs.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
  
  Software Developer: Is the person who builds the software by writing the instructions (code) that tell the computer what to do. His/ her roles include:
    1. Write and test code to make the software work.
    2. Fix any mistakes in the code if something doesn’t work right.
    3. Work with the team to make sure their code fits the big plan.
    4. Keep learning new tools or tricks to make better software.
    
  Project Manger: is like the team coach who keeps everyone on track and makes sure the software gets done on time. His/ her roles include:
    1. Make a plan with steps and deadlines.
    2. Talk to the team and customers to keep everyone happy and informed.
    3. Solve problems, like finding extra help if the team’s stuck or behind.
    4. Watch the budget and time so the project doesn’t cost too much or run late.
  
  Quality Assuarane Engineer: checks the software to make sure it’s good enough to use. They test it to find problems before users do. His/ her roles include:
    1. Test the software by trying it out.
    2. Write down what’s wrong and tell the developers so they can fix it.
    3. Make sure the software does what it’s supposed to, like meeting the wishlist from the start.
    4. Check it again after fixes to make sure it’s all good.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

Integrated Development Environments - An IDE is a software application that provides a comprehensive set of tools for writing, testing, and debugging code in one place.
Importane of IDEs: 1. Makes coding faster by suggesting words or fixing small mistakes as you type, like autocorrect on your phone.
                   2. Lets developers test their code right there to see if it works, without switching tools.
                   3. Spots errors early, like a spellchecker, so they don’t turn into bigger problems later.
                   4. Keeps things organized—code, files, and settings all stay together.

Examples: Visual Studio Code, IntelliJ IDEA, PyCharm

Version Control Systems (VCS)- A VCS is a system that tracks and manages changes to code over time. It allows multiple developers to collaborate, revert to previous versions, and maintain an organized development history.

Importance of VCS: 1. Saves old versions, so if a new change messes things up, they can undo it easily.
                   2. Helps teams work together—everyone can add their part without stepping on each other’s toes.
                   3. Tracks who changed what and why, making it easier to fix mistakes or understand the project.
                   4. Keeps the code safe by storing it in one central spot, like a backup drive.

Examples: GIT, Subversion (SVN)

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
  1: Bugs and Errors
Bugs are mistakes in the code that make software act up and they’re tough because they can hide and take time to fix. Software engineers deal with this by testing the software a lot as they build it, using tools that spot errors right away, and asking a teammate to double-check their work, so the software ends up working smoothly with fewer hiccups.

  2: Changing Requirements
Sometimes customers decide they want something different after the project starts which can throw off the whole plan and frustrate the team. To handle this, engineers talk a ton with customers at the beginning to nail down what’s needed, use a flexible approach like Agile to adjust easily, and write down every change, keeping the project on track no matter what shifts.

 3: Time Pressure
Tight deadlines mean engineers have to rush which can lead to sloppy code or tired workers. They tackle this by splitting the work into smaller pieces to finish bit by bit, adding extra time in the plan for surprises, and focusing only on the must-do stuff, so the software gets done on time without falling apart.

4: Teamwork Troubles
When a team doesn’t talk well, things get messy which slows everything down. Engineers fix this by having quick daily chats to stay in sync, using tools to share code and track changes, and setting easy rules for working together, making the team run like a smooth machine.

 5: Keeping Up with New Tech
Tech changes super fast and engineers struggle to learn it all while busy, risking outdated skills. They stay sharp by spending a little time each week trying new tools, watching simple how-to videos, and practicing on tiny projects, so they’re always ready with the latest know-how for any job.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

  1. Unit Testing- Unit testing is when developers check the tiniest bits of the software to make sure each piece works perfectly on its own. They write quick tests while coding and run them to catch mistakes early, which is super important because fixing small problems right away stops them from growing into big headaches later, giving the software a strong foundation that’s less likely to break.
  2. Integration Testing-Integration testing happens after the small pieces are good—it’s about making sure those pieces work together. Testers hook up a few parts and test them as a group, which matters because it catches mix-up problems that could crash the software if they’re missed, keeping everything running smooth when combined.
  3. System Testing-System testing is testing the whole software once it’s all put together. Testers act like users, clicking around and trying everything to spot big issues like slowdowns or crashes, which is key because it shows the software can handle real life, not just bits and pieces, ensuring it’s solid and ready to go live.
  4. Acceptance Testing-Acceptance testing is the last step where the customer tries the software to see if it matches what they asked for. It’s all about making sure the software fits the original wishlist and feels right to use, which is huge because it proves the team didn’t just build something cool, but something people actually want and will enjoy.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the skill of writing clear and specific instructions to get the best response from an AI models.
It's importanve:
  1. Gets Better Answers- A well-structured prompt helps AI understand exactly what the user wants, leading to more accurate and relevant responses.
  2. Saves Time- Clear prompts reduce the need for repeated questions or corrections, making interactions with AI more efficient.
  3. Gives More Control Over AI Responses- Prompt engineering allows users to shape AI responses by adjusting wording, tone, and detail level.
  4. Helps in Different Tasks- AI can assist in various fields like writing, coding, and data analysis, but only if the prompts are clear.
  5. Reduces Mistakes and Bias- Carefully written prompts help minimize AI-generated errors, misleading information, or biased responses.

     
Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
Vague Prompt:Tell me about technology.
Improved Prompt:Explain how artificial intelligence is used in healthcare, including at least three examples.
Why the Improved Prompt is More Effective: The improved prompt is clearer because it specifies the topic instead of just "technology." It also defines the expected response structure by asking for three examples, ensuring a more focused and detailed answer. Additionally, it is concise and directly communicates what the user wants, reducing the chances of an overly broad or irrelevant response.
