[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18420655&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering refer to the processes of designing, developing, testing and maintainance of software applications. It's importance include:
  1. Ensures that softwares are reliable and function as expected.
  2. Designs systems that can handle more users and data as they grow, without losing performance.
  3. Optimizes software to run smoothly, saving resources and improving user experience.
  4. Identifies and fixes security issues to protect sensitive data and prevent cyberattacks.


Identify and describe at least three key milestones in the evolution of software engineering.
  1. Birth of Software Engineering (1960s)- Back then, coding was a free-for-all with no real plan, but software was getting tricky and messy. In the 1960s, during the "Software Crisis," people started calling it “software engineering” to make it more serious. It pushed for organized ways to build software, like using better methods and early coding languages. This kicked off software engineering as a real job.
  2. Waterfall Model (1970s)- In the 1970s, the Waterfall Model came along—a step-by-step way to make software. You finish one part (like planning or coding) before moving to the next, like a checklist. It made things orderly and clear, helping teams stay on track. Even though it’s stiff, it shaped how people think about building software and still gets used sometimes.
  3. Agile Software Development (1990s-2000s)- In the late 1990s and 2000s, Agile showed up, shaking things up. It’s all about being flexible, working with users, and building software in small, quick chunks. The Agile Manifesto in 2001 laid out the big ideas, like adapting fast and delivering often. It sped up development, made teamwork better

List and briefly explain the phases of the Software Development Life Cycle.
  1. Requirements Gathering and Analysis: Talk to the people who want the software to figure out what it needs to do. Write down all the details.
  2. System Design: Plan how the software will work and look.
  3. Coding: This is where people type the instructions (code) that tell the computer what to do, based on the plan.
  4. Testing: Check the software to find bugs and fix them. Make sure it does what it’s supposed to.
  5. Deployment: Put the software out into the world—like for people to use it.
  6. Maintenance: Keep an eye on it after it’s out. Fix problems, add new stuff, or update it so it doesn’t get old and stop working.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
  Waterfall methodology: Is a straightforward way to build software where you finish one step before starting the next. It’s great because it’s super organized and you know what you’ll get from the start but if something goes wrong late, it’s tough to fix earlier steps, and it takes longer since users only see it at the end. It works best for projects like large government systems or infrastructure software.
  Agile methodology: Software is build in small pieces, show them to users, get their ideas, and keep improving it bit by bit. It’s awesome because you can change things anytime and get usable stuff out fast, like a basic app you update based on what people say. The downside is it’s less predictable and needs lots of teamwork, which can feel messy if you like strict plans. It’s perfect for something like a social media app, where you start simple and add features as users’ wants change.
  How they compare: Waterfall moves in a straight line with no turning back, while Agile zigzags with lots of check-ins; Waterfall locks the plan early and hates changes, but Agile expects them and adjusts all the time. Waterfall takes longer to finish fully, while Agile gets stuff out quicker, and Waterfall shows users the final product at the end, but Agile involves them from the start. Waterfall plans everything upfront, whereas Agile figures it out as it goes—each fits different needs.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
  Software Developer: Is the person who builds the software by writing the instructions (code) that tell the computer what to do. His/ her roles include:
    1. Write and test code to make the software work.
    2. Fix any mistakes in the code if something doesn’t work right.
    3. Work with the team to make sure their code fits the big plan.
    4. Keep learning new tools or tricks to make better software.
    
  Project Manger: is like the team coach who keeps everyone on track and makes sure the software gets done on time. His/ her roles include:
    1. Make a plan with steps and deadlines.
    2. Talk to the team and customers to keep everyone happy and informed.
    3. Solve problems, like finding extra help if the team’s stuck or behind.
    4. Watch the budget and time so the project doesn’t cost too much or run late.
  
  Quality Assuarane Engineer: checks the software to make sure it’s good enough to use. They test it to find problems before users do. His/ her roles include:
    1. Test the software by trying it out.
    2. Write down what’s wrong and tell the developers so they can fix it.
    3. Make sure the software does what it’s supposed to, like meeting the wishlist from the start.
    4. Check it again after fixes to make sure it’s all good.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.


Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
